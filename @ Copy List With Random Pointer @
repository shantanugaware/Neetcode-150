Intuition
We use 2 pass algorithm to get to solution. In this, we use first pass to create a copy node of original list's node, using hash map.
And in 2nd pass we use that hashmap to map next, and random pointers from original list's node to out copied nodes.

Complexity
Time complexity:
O(n)

Space complexity:
O(n)

Code
```
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        Node curr = head;
        Map<Node, Node> oldL = new HashMap<>();
        oldL.put(null,null);
        while(curr!=null){
            Node copy = new Node(curr.val);
            oldL.put(curr, copy);
            curr = curr.next;
        }
        curr = head;
        while(curr!=null){
            Node copy = oldL.get(curr);
            copy.next = oldL.get(curr.next);
            copy.random = oldL.get(curr.random);
            curr = curr.next;
        }
        return oldL.get(head);
    }
}
```
